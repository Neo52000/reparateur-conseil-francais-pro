
/**
 * Service de nettoyage et normalisation du contenu
 */

export interface PreprocessOptions {
  preserveFormatting?: boolean;
  cleanMetadata?: boolean;
  convertCallouts?: boolean;
  normalizeLineBreaks?: boolean;
  conservative?: boolean;
  preserveTables?: boolean;
}

export class ContentCleaner {
  /**
   * Pr√©serve les tableaux Markdown
   */
  static preserveMarkdownTables(content: string): string {
    // D√©tecter et pr√©server les tableaux Markdown
    return content.replace(
      /((?:\|[^|\n]*)+\|[\n\r]*)+/g,
      (tableMatch) => {
        const lines = tableMatch.split(/[\n\r]+/).filter(line => line.trim());
        return lines
          .map(line => {
            // Nettoyer les espaces autour des pipes tout en pr√©servant la structure
            return line.replace(/\s*\|\s*/g, ' | ').replace(/^\s*\|\s*/, '| ').replace(/\s*\|\s*$/, ' |');
          })
          .join('\n') + '\n';
      }
    );
  }

  /**
   * V√©rifie si une ligne fait partie d'un tableau Markdown
   */
  static isTableLine(line: string): boolean {
    return /^\s*\|.*\|\s*$/.test(line) || /^\s*\|[\s-:]*\|\s*$/.test(line);
  }

  /**
   * Nettoie les m√©tadonn√©es de mani√®re conservatrice
   */
  static cleanMetadataConservative(content: string): string {
    return content
      // Supprimer seulement les timestamps d'export √©vidents
      .replace(/^Exported on \d{4}-\d{2}-\d{2}.*$/gm, '')
      .replace(/^Generated by .* on \d{4}-\d{2}-\d{2}.*$/gm, '')
      // Nettoyer les espaces excessifs seulement
      .replace(/\n{4,}/g, '\n\n\n')
      .trim();
  }

  /**
   * Normalise les sauts de ligne de mani√®re conservatrice en pr√©servant les tableaux
   */
  static normalizeLineBreaksConservative(content: string): string {
    const lines = content.split('\n');
    const result: string[] = [];
    let inTable = false;
    let consecutiveEmptyLines = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isCurrentLineTable = this.isTableLine(line);
      const isNextLineTable = i < lines.length - 1 ? this.isTableLine(lines[i + 1]) : false;

      // D√©tecter le d√©but/fin d'un tableau
      if (isCurrentLineTable && !inTable) {
        inTable = true;
      } else if (!isCurrentLineTable && !isNextLineTable && inTable) {
        inTable = false;
      }

      if (line.trim() === '') {
        consecutiveEmptyLines++;
        // Dans un tableau, pr√©server au maximum 1 ligne vide
        if (inTable && consecutiveEmptyLines <= 1) {
          result.push(line);
        }
        // Hors tableau, limiter √† 2 lignes vides cons√©cutives
        else if (!inTable && consecutiveEmptyLines <= 2) {
          result.push(line);
        }
      } else {
        consecutiveEmptyLines = 0;
        result.push(line);
      }
    }

    return result.join('\n')
      // Normaliser les fins de ligne
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n');
  }

  /**
   * Nettoie les m√©tadonn√©es et artifacts d'export (mode normal)
   */
  static cleanMetadata(content: string): string {
    return content
      // Supprimer les timestamps d'export
      .replace(/^Exported on.*$/gm, '')
      .replace(/^Generated by.*$/gm, '')
      .replace(/^Created with.*$/gm, '')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  }

  /**
   * Normalise les sauts de ligne (mode normal) en pr√©servant les tableaux
   */
  static normalizeLineBreaks(content: string): string {
    const lines = content.split('\n');
    const result: string[] = [];
    let inTable = false;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const isCurrentLineTable = this.isTableLine(line);
      const isNextLineTable = i < lines.length - 1 ? this.isTableLine(lines[i + 1]) : false;

      // D√©tecter le d√©but/fin d'un tableau
      if (isCurrentLineTable && !inTable) {
        inTable = true;
      } else if (!isCurrentLineTable && !isNextLineTable && inTable) {
        inTable = false;
      }

      result.push(line);
    }

    return result.join('\n')
      // Normaliser les fins de ligne
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      // Appliquer les r√®gles normales seulement hors des tableaux
      .replace(/(\n-\s.*)\n\n(\s*-\s)/g, '$1\n$2')
      .replace(/(\n\d+\.\s.*)\n\n(\s*\d+\.\s)/g, '$1\n$2');
  }

  /**
   * Convertit les callouts en format markdown standard
   */
  static convertCallouts(content: string): string {
    return content
      // Convertir les callouts avec √©mojis
      .replace(/^(\s*)üí°\s*(.+)$/gm, '$1> üí° **Conseil**: $2')
      .replace(/^(\s*)‚ö†Ô∏è\s*(.+)$/gm, '$1> ‚ö†Ô∏è **Attention**: $2')
      .replace(/^(\s*)üìù\s*(.+)$/gm, '$1> üìù **Note**: $2')
      .replace(/^(\s*)‚úÖ\s*(.+)$/gm, '$1> ‚úÖ **Succ√®s**: $2')
      .replace(/^(\s*)‚ùå\s*(.+)$/gm, '$1> ‚ùå **Erreur**: $2')
      .replace(/^(\s*)üîç\s*(.+)$/gm, '$1> üîç **Inspection**: $2')
      .replace(/^(\s*)NOTE:\s*(.+)$/gm, '$1> üìù **Note**: $2')
      .replace(/^(\s*)WARNING:\s*(.+)$/gm, '$1> ‚ö†Ô∏è **Attention**: $2')
      .replace(/^(\s*)TIP:\s*(.+)$/gm, '$1> üí° **Conseil**: $2');
  }

  /**
   * Pr√©serve et am√©liore le formatage
   */
  static preserveFormatting(content: string): string {
    let processed = content;

    // Pr√©server les tableaux en premier
    processed = this.preserveMarkdownTables(processed);

    // Am√©liorer les autres √©l√©ments de formatage
    processed = processed
      // Am√©liorer les listes √† puces
      .replace(/^\s*[\*\+\-]\s+/gm, '- ')
      .replace(/```(\w+)?\n([\s\S]*?)\n```/g, (match, lang, code) => {
        return `\`\`\`${lang || ''}\n${code}\n\`\`\``;
      })
      .replace(/^#{1,6}\s+/gm, (match) => match.trim() + ' ')
      .replace(/\[([^\]]+)\]\s*\(\s*([^)]+)\s*\)/g, '[$1]($2)');

    return processed;
  }

  /**
   * Conversion sp√©cifique pour les exports Claude.ai (mode conservateur)
   */
  static processClaudeExport(content: string): string {
    return content
      // Pr√©server les blockquotes Claude sans les transformer
      .replace(/^>\s*(.+)$/gm, '> $1')
      // Am√©liorer les listes de t√¢ches seulement si elles sont malform√©es
      .replace(/^-\s*\[\s*\]\s*(.+)$/gm, '- [ ] $1')
      .replace(/^-\s*\[x\]\s*(.+)$/gm, '- [x] $1');
  }
}
