
/**
 * Service de preprocessing pour normaliser le contenu import√©
 * G√®re les formats sp√©cifiques et nettoie le contenu
 */

export interface PreprocessOptions {
  preserveFormatting?: boolean;
  cleanMetadata?: boolean;
  convertCallouts?: boolean;
  normalizeLineBreaks?: boolean;
}

export interface DetectedFormat {
  source: 'claude' | 'chatgpt' | 'notion' | 'markdown' | 'unknown';
  confidence: number;
  features: string[];
}

export class ContentPreprocessor {
  
  /**
   * D√©tecte le format source du contenu
   */
  static detectFormat(content: string): DetectedFormat {
    const features: string[] = [];
    let source: DetectedFormat['source'] = 'unknown';
    let confidence = 0;

    // Patterns Claude.ai
    if (content.includes('```') && content.includes('> ') && content.match(/\*\*[^*]+\*\*/)) {
      features.push('claude-markdown', 'code-blocks', 'blockquotes', 'bold-text');
      source = 'claude';
      confidence = 0.8;
    }

    // Patterns ChatGPT
    if (content.match(/\d+\.\s+/) && content.includes('**') && content.includes('###')) {
      features.push('numbered-lists', 'headers', 'bold-text');
      if (source === 'unknown') {
        source = 'chatgpt';
        confidence = 0.7;
      }
    }

    // Patterns Notion
    if (content.includes('üí°') || content.includes('‚ö†Ô∏è') || content.includes('üìù')) {
      features.push('emoji-callouts', 'rich-formatting');
      if (source === 'unknown') {
        source = 'notion';
        confidence = 0.6;
      }
    }

    // Standard Markdown
    if (content.includes('# ') || content.includes('## ') || content.includes('- ')) {
      features.push('standard-markdown');
      if (source === 'unknown') {
        source = 'markdown';
        confidence = 0.5;
      }
    }

    return { source, confidence, features };
  }

  /**
   * Nettoie et normalise le contenu
   */
  static preprocess(content: string, options: PreprocessOptions = {}): string {
    const {
      preserveFormatting = true,
      cleanMetadata = true,
      convertCallouts = true,
      normalizeLineBreaks = true
    } = options;

    let processed = content;

    // Nettoyer les m√©tadonn√©es communes
    if (cleanMetadata) {
      processed = this.cleanMetadata(processed);
    }

    // Normaliser les sauts de ligne
    if (normalizeLineBreaks) {
      processed = this.normalizeLineBreaks(processed);
    }

    // Convertir les callouts/admonitions
    if (convertCallouts) {
      processed = this.convertCallouts(processed);
    }

    // Pr√©server ou am√©liorer le formatage
    if (preserveFormatting) {
      processed = this.preserveFormatting(processed);
    }

    return processed;
  }

  /**
   * Nettoie les m√©tadonn√©es et artifacts d'export
   */
  private static cleanMetadata(content: string): string {
    return content
      // Supprimer les timestamps d'export
      .replace(/^Exported on.*$/gm, '')
      // Supprimer les signatures d'outils
      .replace(/^Generated by.*$/gm, '')
      .replace(/^Created with.*$/gm, '')
      // Nettoyer les espaces multiples
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  }

  /**
   * Normalise les sauts de ligne
   */
  private static normalizeLineBreaks(content: string): string {
    return content
      // Normaliser les fins de ligne
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      // √âviter les sauts de ligne excessifs dans les listes
      .replace(/(\n-\s.*)\n\n(\s*-\s)/g, '$1\n$2')
      .replace(/(\n\d+\.\s.*)\n\n(\s*\d+\.\s)/g, '$1\n$2');
  }

  /**
   * Convertit les callouts en format markdown standard
   */
  private static convertCallouts(content: string): string {
    return content
      // Convertir les callouts avec √©mojis
      .replace(/^(\s*)üí°\s*(.+)$/gm, '$1> üí° **Conseil**: $2')
      .replace(/^(\s*)‚ö†Ô∏è\s*(.+)$/gm, '$1> ‚ö†Ô∏è **Attention**: $2')
      .replace(/^(\s*)üìù\s*(.+)$/gm, '$1> üìù **Note**: $2')
      .replace(/^(\s*)‚úÖ\s*(.+)$/gm, '$1> ‚úÖ **Succ√®s**: $2')
      .replace(/^(\s*)‚ùå\s*(.+)$/gm, '$1> ‚ùå **Erreur**: $2')
      .replace(/^(\s*)üîç\s*(.+)$/gm, '$1> üîç **Inspection**: $2')
      // Convertir les callouts textuels
      .replace(/^(\s*)NOTE:\s*(.+)$/gm, '$1> üìù **Note**: $2')
      .replace(/^(\s*)WARNING:\s*(.+)$/gm, '$1> ‚ö†Ô∏è **Attention**: $2')
      .replace(/^(\s*)TIP:\s*(.+)$/gm, '$1> üí° **Conseil**: $2');
  }

  /**
   * Pr√©serve et am√©liore le formatage
   */
  private static preserveFormatting(content: string): string {
    return content
      // Am√©liorer les listes √† puces
      .replace(/^\s*[\*\+\-]\s+/gm, '- ')
      // Pr√©server les espaces dans les code blocks
      .replace(/```(\w+)?\n([\s\S]*?)\n```/g, (match, lang, code) => {
        return `\`\`\`${lang || ''}\n${code}\n\`\`\``;
      })
      // Am√©liorer les titres
      .replace(/^#{1,6}\s+/gm, (match) => match.trim() + ' ')
      // Nettoyer les liens
      .replace(/\[([^\]]+)\]\s*\(\s*([^)]+)\s*\)/g, '[$1]($2)');
  }

  /**
   * Conversion sp√©cifique pour les exports Claude.ai
   */
  static processClaudeExport(content: string): string {
    return content
      // Pr√©server les blockquotes Claude
      .replace(/^>\s*(.+)$/gm, '> $1')
      // Am√©liorer les listes de t√¢ches
      .replace(/^-\s*\[\s*\]\s*(.+)$/gm, '- [ ] $1')
      .replace(/^-\s*\[x\]\s*(.+)$/gm, '- [x] $1')
      // Pr√©server les code blocks avec langage
      .replace(/```(\w+)\n([\s\S]*?)```/g, '```$1\n$2\n```');
  }

  /**
   * Validation du contenu trait√©
   */
  static validateProcessedContent(content: string): { isValid: boolean; issues: string[] } {
    const issues: string[] = [];
    
    // V√©rifier les code blocks non ferm√©s
    const codeBlocks = content.match(/```/g);
    if (codeBlocks && codeBlocks.length % 2 !== 0) {
      issues.push('Code block non ferm√© d√©tect√©');
    }

    // V√©rifier les liens malform√©s
    const malformedLinks = content.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks) {
      issues.push('Liens malform√©s d√©tect√©s');
    }

    return {
      isValid: issues.length === 0,
      issues
    };
  }
}
