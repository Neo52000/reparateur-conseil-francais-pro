
/**
 * Service de preprocessing pour normaliser le contenu importÃ©
 * GÃ¨re les formats spÃ©cifiques et nettoie le contenu de maniÃ¨re conservatrice
 */

export interface PreprocessOptions {
  preserveFormatting?: boolean;
  cleanMetadata?: boolean;
  convertCallouts?: boolean;
  normalizeLineBreaks?: boolean;
  conservative?: boolean; // Nouveau: mode conservateur
}

export interface DetectedFormat {
  source: 'claude' | 'chatgpt' | 'notion' | 'markdown' | 'unknown';
  confidence: number;
  features: string[];
}

export class ContentPreprocessor {
  
  /**
   * DÃ©tecte le format source du contenu
   */
  static detectFormat(content: string): DetectedFormat {
    const features: string[] = [];
    let source: DetectedFormat['source'] = 'unknown';
    let confidence = 0;

    // Patterns Claude.ai - plus prÃ©cis
    const claudePatterns = [
      /```[\w]*\n[\s\S]*?\n```/g, // Code blocks
      /^>\s+/gm, // Blockquotes
      /\*\*[^*]+\*\*/g, // Bold text
      /^#{1,6}\s+/gm // Headers
    ];
    
    let claudeScore = 0;
    claudePatterns.forEach(pattern => {
      if (pattern.test(content)) claudeScore++;
    });
    
    if (claudeScore >= 3) {
      features.push('claude-markdown', 'code-blocks', 'blockquotes', 'bold-text');
      source = 'claude';
      confidence = Math.min(0.9, 0.6 + (claudeScore * 0.1));
    }

    // Patterns ChatGPT
    if (content.match(/^\d+\.\s+/gm) && content.includes('**') && content.includes('###')) {
      features.push('numbered-lists', 'headers', 'bold-text');
      if (source === 'unknown') {
        source = 'chatgpt';
        confidence = 0.7;
      }
    }

    // Patterns Notion - plus spÃ©cifique
    const notionEmojis = ['ğŸ’¡', 'âš ï¸', 'ğŸ“', 'âœ…', 'âŒ', 'ğŸ”', 'ğŸ“Š', 'ğŸ¯'];
    const emojiCount = notionEmojis.filter(emoji => content.includes(emoji)).length;
    
    if (emojiCount >= 2) {
      features.push('emoji-callouts', 'rich-formatting');
      if (source === 'unknown') {
        source = 'notion';
        confidence = 0.6 + (emojiCount * 0.05);
      }
    }

    // Standard Markdown
    if (content.includes('# ') || content.includes('## ') || content.includes('- ')) {
      features.push('standard-markdown');
      if (source === 'unknown') {
        source = 'markdown';
        confidence = 0.5;
      }
    }

    return { source, confidence, features };
  }

  /**
   * Nettoie et normalise le contenu de maniÃ¨re conservatrice
   */
  static preprocess(content: string, options: PreprocessOptions = {}): string {
    const {
      preserveFormatting = true,
      cleanMetadata = true,
      convertCallouts = false, // DÃ©sactivÃ© par dÃ©faut pour Ãªtre plus conservateur
      normalizeLineBreaks = true,
      conservative = true // Nouveau mode conservateur activÃ© par dÃ©faut
    } = options;

    let processed = content;

    // Mode conservateur : transformations minimales
    if (conservative) {
      // Nettoyer seulement les mÃ©tadonnÃ©es Ã©videntes
      if (cleanMetadata) {
        processed = this.cleanMetadataConservative(processed);
      }
      
      // Normaliser seulement les sauts de ligne excessifs
      if (normalizeLineBreaks) {
        processed = this.normalizeLineBreaksConservative(processed);
      }
      
      return processed;
    }

    // Mode normal (plus agressif)
    if (cleanMetadata) {
      processed = this.cleanMetadata(processed);
    }

    if (normalizeLineBreaks) {
      processed = this.normalizeLineBreaks(processed);
    }

    if (convertCallouts) {
      processed = this.convertCallouts(processed);
    }

    if (preserveFormatting) {
      processed = this.preserveFormatting(processed);
    }

    return processed;
  }

  /**
   * Nettoie les mÃ©tadonnÃ©es de maniÃ¨re conservatrice
   */
  private static cleanMetadataConservative(content: string): string {
    return content
      // Supprimer seulement les timestamps d'export Ã©vidents
      .replace(/^Exported on \d{4}-\d{2}-\d{2}.*$/gm, '')
      .replace(/^Generated by .* on \d{4}-\d{2}-\d{2}.*$/gm, '')
      // Nettoyer les espaces excessifs seulement
      .replace(/\n{4,}/g, '\n\n\n')
      .trim();
  }

  /**
   * Normalise les sauts de ligne de maniÃ¨re conservatrice
   */
  private static normalizeLineBreaksConservative(content: string): string {
    return content
      // Normaliser les fins de ligne seulement
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      // RÃ©duire les sauts de ligne excessifs (4+ vers 2)
      .replace(/\n{4,}/g, '\n\n');
  }

  /**
   * Nettoie les mÃ©tadonnÃ©es et artifacts d'export (mode normal)
   */
  private static cleanMetadata(content: string): string {
    return content
      // Supprimer les timestamps d'export
      .replace(/^Exported on.*$/gm, '')
      .replace(/^Generated by.*$/gm, '')
      .replace(/^Created with.*$/gm, '')
      .replace(/\n{3,}/g, '\n\n')
      .trim();
  }

  /**
   * Normalise les sauts de ligne (mode normal)
   */
  private static normalizeLineBreaks(content: string): string {
    return content
      // Normaliser les fins de ligne
      .replace(/\r\n/g, '\n')
      .replace(/\r/g, '\n')
      .replace(/(\n-\s.*)\n\n(\s*-\s)/g, '$1\n$2')
      .replace(/(\n\d+\.\s.*)\n\n(\s*\d+\.\s)/g, '$1\n$2');
  }

  /**
   * Convertit les callouts en format markdown standard
   */
  private static convertCallouts(content: string): string {
    return content
      // Convertir les callouts avec Ã©mojis
      .replace(/^(\s*)ğŸ’¡\s*(.+)$/gm, '$1> ğŸ’¡ **Conseil**: $2')
      .replace(/^(\s*)âš ï¸\s*(.+)$/gm, '$1> âš ï¸ **Attention**: $2')
      .replace(/^(\s*)ğŸ“\s*(.+)$/gm, '$1> ğŸ“ **Note**: $2')
      .replace(/^(\s*)âœ…\s*(.+)$/gm, '$1> âœ… **SuccÃ¨s**: $2')
      .replace(/^(\s*)âŒ\s*(.+)$/gm, '$1> âŒ **Erreur**: $2')
      .replace(/^(\s*)ğŸ”\s*(.+)$/gm, '$1> ğŸ” **Inspection**: $2')
      .replace(/^(\s*)NOTE:\s*(.+)$/gm, '$1> ğŸ“ **Note**: $2')
      .replace(/^(\s*)WARNING:\s*(.+)$/gm, '$1> âš ï¸ **Attention**: $2')
      .replace(/^(\s*)TIP:\s*(.+)$/gm, '$1> ğŸ’¡ **Conseil**: $2');
  }

  /**
   * PrÃ©serve et amÃ©liore le formatage
   */
  private static preserveFormatting(content: string): string {
    return content
      // AmÃ©liorer les listes Ã  puces
      .replace(/^\s*[\*\+\-]\s+/gm, '- ')
      .replace(/```(\w+)?\n([\s\S]*?)\n```/g, (match, lang, code) => {
        return `\`\`\`${lang || ''}\n${code}\n\`\`\``;
      })
      .replace(/^#{1,6}\s+/gm, (match) => match.trim() + ' ')
      .replace(/\[([^\]]+)\]\s*\(\s*([^)]+)\s*\)/g, '[$1]($2)');
  }

  /**
   * Conversion spÃ©cifique pour les exports Claude.ai (mode conservateur)
   */
  static processClaudeExport(content: string): string {
    return content
      // PrÃ©server les blockquotes Claude sans les transformer
      .replace(/^>\s*(.+)$/gm, '> $1')
      // AmÃ©liorer les listes de tÃ¢ches seulement si elles sont malformÃ©es
      .replace(/^-\s*\[\s*\]\s*(.+)$/gm, '- [ ] $1')
      .replace(/^-\s*\[x\]\s*(.+)$/gm, '- [x] $1');
  }

  /**
   * Validation du contenu traitÃ©
   */
  static validateProcessedContent(content: string): { isValid: boolean; issues: string[] } {
    const issues: string[] = [];
    
    // VÃ©rifier les code blocks non fermÃ©s
    const codeBlocks = content.match(/```/g);
    if (codeBlocks && codeBlocks.length % 2 !== 0) {
      issues.push('Code block non fermÃ© dÃ©tectÃ©');
    }

    const malformedLinks = content.match(/\[([^\]]*)\]\([^)]*$/gm);
    if (malformedLinks) {
      issues.push('Liens malformÃ©s dÃ©tectÃ©s');
    }

    return {
      isValid: issues.length === 0,
      issues
    };
  }

  /**
   * Compare deux contenus et retourne les diffÃ©rences principales
   */
  static compareContents(original: string, processed: string): {
    linesChanged: number;
    charactersChanged: number;
    majorChanges: string[];
  } {
    const originalLines = original.split('\n');
    const processedLines = processed.split('\n');
    
    let linesChanged = 0;
    const majorChanges: string[] = [];
    
    // Compter les lignes modifiÃ©es
    const maxLines = Math.max(originalLines.length, processedLines.length);
    for (let i = 0; i < maxLines; i++) {
      if (originalLines[i] !== processedLines[i]) {
        linesChanged++;
      }
    }
    
    // DÃ©tecter les changements majeurs
    if (original.length !== processed.length) {
      const diff = Math.abs(original.length - processed.length);
      if (diff > original.length * 0.1) {
        majorChanges.push(`Taille du contenu modifiÃ©e de ${diff} caractÃ¨res`);
      }
    }
    
    // DÃ©tecter les transformations de callouts
    const originalCallouts = (original.match(/[ğŸ’¡âš ï¸ğŸ“âœ…âŒğŸ”]/g) || []).length;
    const processedCallouts = (processed.match(/[ğŸ’¡âš ï¸ğŸ“âœ…âŒğŸ”]/g) || []).length;
    if (originalCallouts !== processedCallouts) {
      majorChanges.push('Callouts/Ã©mojis modifiÃ©s');
    }
    
    return {
      linesChanged,
      charactersChanged: Math.abs(original.length - processed.length),
      majorChanges
    };
  }
}
